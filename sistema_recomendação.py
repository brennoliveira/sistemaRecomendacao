# -*- coding: utf-8 -*-
"""SISTEMA_RECOMENDAÇÃO

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-qdMOb6TgGA3DBIthYVYxOeyXL524Et7
"""

import networkx as nx
import pandas as pd
from collections import defaultdict

# INICIALIZAÇÃO DE UM GRAFO VAZIO
G=nx.Graph()

# LEITURA DOS DADOS DE MOVIES E RATINGS 
movies = pd.read_csv("./movies.csv")
ratings = pd.read_csv("./ratings.csv")

# INSERÇÃO DOS VÉRTICES DE FILME E USUÁRIO EM UM GRAFO BIPARTIDO
for u in ratings.userId.unique():
    nome = "u" + str(int(u));
    G.add_node(nome, bipartite = 'user')

for i in movies.movieId:
    nome = "m" + str(int(i));
    G.add_node(nome, bipartite = 'movie')

#INSERÇÃO DAS ARESTAS ENTRE USUÁRIOS E FILMES
for i in ratings.values:
    G.add_edge('u'+str(int(i[0])), 'm'+str(int(i[1])))

# MÉTODO PARA RETORNAR TODOS OS VÉRTICES DE UM PARTIDO
def get_vertices_por_partido(G, partido):
    vertices = []
    for v in G.nodes():
        if G.nodes[str(v)]['bipartite'] == partido:
            vertices.append(v)
    return vertices

# MÉTODO QUE RETORNA TODOS OS FILMES EM COMUM ASSISTIDOS POR 2 USUÁRIOS PARAMETRIZADOS
def qtd_filmes_assistidos_em_comum(G, user1, user2):
    user1_adjacentes = G.neighbors(user1)
    user2_adjacentes = G.neighbors(user2)
    return set(user1_adjacentes).intersection(user2_adjacentes)

# CALCULA O INDICE DE SIMILARIDADE ENTRE 2 USUARIOS
def similaridade_entre_usuarios(G, user1, user2, qtd_vertices_de_filmes):
    assert G.nodes[user1]['bipartite'] == 'user'
    assert G.nodes[user2]['bipartite'] == 'user'

    qtd_filmes_assistidos = qtd_filmes_assistidos_em_comum(G, user1, user2)

    return len(qtd_filmes_assistidos) / len(qtd_vertices_de_filmes)

# IDENTIFICA QUAL O USUÁRIO MAIS SIMILAR
def usuarios_mais_similares(G, usuario_final, qtd_vertices_de_usuarios, qtd_vertices_de_filmes):
    assert G.nodes[usuario_final]['bipartite'] == 'user'

    qtd_vertices_de_usuarios = set(qtd_vertices_de_usuarios)
    qtd_vertices_de_usuarios.remove(usuario_final)

    usuarios_similares = defaultdict(list)
    for n in qtd_vertices_de_usuarios:
        usuario_similar = similaridade_entre_usuarios(G, usuario_final, n, qtd_vertices_de_filmes)
        usuarios_similares[usuario_similar].append(n)

    maior_similaridade = max(usuarios_similares.keys())

    return usuarios_similares[maior_similaridade]

# IMPRIME OS TÍTULOS DOS FILMES
def retornar_filmes(filmes):
    for filme in filmes:
        filme = filme.split('m')[1]
        titulo_filme = movies.loc[movies['movieId'] == int(filme)].iloc[0].title
        print(titulo_filme)

# RECOMENDA FILMES PARA UM USUÁRIO FINAL A PARTIR DE UM SIMILAR
def recomendar_filmes(G, usuario_similar, usuario_final):
    filmes_assistido_por_usuario_similar = set(G.neighbors(usuario_similar))
    filmes_assistidos_por_usuario_final = set(G.neighbors(usuario_final))
    filmes = list(filmes_assistido_por_usuario_similar.difference(filmes_assistidos_por_usuario_final))

    #LIMITA A RECOMENDAÇÃO PARA 10 FILMES
    return retornar_filmes(filmes[:10])

usuario = 'u' + input('Informe um usuário (1 a 610): ')
qtd_vertices_de_usuarios = get_vertices_por_partido(G, 'user')
qtd_vertices_de_filmes = get_vertices_por_partido(G, 'movie')
usuario_similar = usuarios_mais_similares(G, usuario, qtd_vertices_de_usuarios, qtd_vertices_de_filmes)
recomendar_filmes(G, usuario_similar[0], usuario)